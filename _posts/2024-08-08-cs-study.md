---
# 제목
title: "CS 관련 공부 (1) 운영체제란!"
# 부가 내용 미리보기
excerpt: "운영체제, 목적, CPU와 메모리 구조, 커널과 시스템 콜에 대해 작성을 한 내용입니다."

# 해당 카테고리
categories:
  - CS
# 태그
tags:
  - [cs, study, 기술 면접 대비]

#
permalink: /cs/study/

toc: true
toc_sticky: false

date: 2024-08-08

last_modified_at: 2024-11-10

# true 활성 (default), false 비활성
published: false
---

# 🦥 [운영체제]

> 책을 읽고 내가 이해하기 쉽게, 기억하기 쉽게 작성한 게시물입니다.

## 운영체제란?

> **O**perating **S**ystem 은 컴퓨터 시스템의 **자원 관리**,  
> 사용자에게 컴퓨터를 사용할 수 있는 **환경을 제공**해주는 역할을 한다.

---

## [운영체제의 목적]

> **한정된 컴퓨터의 자원을 관리** 하기 위함이다.

1. 처리 능력 향상 : OS 는 자원 관리를 통해 일정시간 안에 시스팀 처리량을 향상시킨다.
2. 반환 시간 단축 : OS 는 사용자가 요청한 작업의 완료 되어지는 시간을 단축시킨다.
3. 사용 가능도 향상 : OS 는 사용자가 컴퓨터 사용해야할때 자원을 즉시 제공해준다.
4. 신뢰도 향상 : OS 는 입력한 값에 대한 결과 값을 정확하게 줄수 있도록 신뢰도를 향상해야한다.

OS 는 하드웨어와 소프트웨어를 이어주는 계층이며, 한정된 자원에서 빠르게 문제를 해결하는 것이 목적이다.
그래서 OS 성능 평가 기준으로 사용된다.

---

## [CPU 와 메모리 구조]

> CPU 는 연산을 처리하고 수행하며, **프로세서** 라고 불린다.  
> 메모리는 데이터를 기억하기 위한 장치이다.

> 주 기억장치인 메인 메모리는 우리가 흔히 말하는 RAM 을 가르키는 말이다.

> 보조 기억장치는 **SSD**(Solid State Drive), **HDD**(Hard Disk Drive) 등을 가르킨다.

휘발성 메모리(전원 나가면 사라짐) => **주** 기억장치  
비휘발성 메모리(전원이 나가도 사라지지 않음) => **보조** 기억장치

메모리는 CPU 빠르게 접근 하도록 아래의 계층 구조로 나뉜다.

---

## [커널과 시스템 콜]

> 커널은 OS 의 핵심요소, 컴퓨터 하드웨어와 프로세스의 보안, 자원관리, 하드웨어 추상화 같은 중요한 역할을 수행한다. **특히**, 자원 관리를 위해 CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등을 담당한다.

OS 는 중요자원 보호를 위해 커널모드, 사용자모드 두가지가 있다.

커널 모드 : 하드웨어에 직접 접근해 메모리, cpu 같은 자원을 사용할 수 있다.

사용자 모드 : 커널모드의 자원에 접근할수 없게 제한을 두어 자원에 접근하려면 **_시스템 콜_**을 호출해야 자원 사용할 수 있다.

`시스템 콜 : 사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수이다. `

시스템 콜을 사용해 프로세스 제어, 파일 조작, 장치 관리, 데이터의 유지보수, 통신, 보호를 할 수 있다.

대표적 예 :

1. 프로세스 생성 => fork()
2. 부모 프로세스가 자식 프로세스의 수행을 기다리는 wait() 등이 있다.

시스템 콜에서 커널에 매개변수를 전달하는 방법은 3가지이다.

1. 매개변수를 CPU의 레지스터에 직접 전달하는 방식이다. 이 방식은 매개변수의 개수가 레스터의 개수보다 많은 경우에 문제가 될 수 있어서 권장하지 않는다.
2. 매개변수를 메모리에 저장한 후 메모리의 주소 값을 레지스터에 저장하는 방식이다.
3. 매개변수를 프로그램의 스택에 push 하고 OS 에서 pop해 매개변수를 전달하는 방식이다.

---

## [프로세스]

프로세스는 컴퓨터에서 실행중인 하나의 프로그램을 의미한다.

프로세스 = 하나의 프로그램 = 명령어의 집합

OS 는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다.

프로세스는 OS로 부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당 받고 다른 프로세스의 메모리 영역에 접근할 수 없다.

> ### 스택
>
> 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역이다.
> 높은 주소 값에서 낮은 주소값으로 메모리 할당되며, 영역 크기는 컴파일 때 결정된다.

> ### 힙
>
> 사용자에 의해 동적 메모리 할당이 일어나는 영역이다.  
> C 언어에서 malloc() 으로 할당되는 영역,
> 낮은 주소 값에서 높은 주소 값으로 메모리 할당되며, 영역 크기는 런타임 때 결정된다.

> ### 데이터
>
> 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다.  
> 데이터 영역은 세부적으로 BSS(Block Stated Symbol) 영역과 데이터 영역으로 나눌수 있다. BSS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장한다.

> ### 코드
>
> 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로, 텍스트 영역이라고도 한다.

스택 영역과 힙 영역은 동적으로 메모리 할당이 가능해서 두영역사이에 빈공간이 존재한다.
스택 영역은 `후입선출(LIFO)`, 높은 주소값 -> 낮은 주소값 순서로 사용!
힙 영역은 `선입선출(FIFO)`, 낮은 주소값 -> 높은 주소값 순서로 사용!

하지만 메모리 영역을 공유하기 떄문에 서로의 영역을 침범하는 문제가 생긴다.
스택 영역이 힙 영역을 침범하는 경우 => 스택 오버플로우(stack overflow)
힙 영역이 스택 영역을 침범하는 경우 => 힙 오버플로우(heap overflow)

오버플로 : 메모리 공간에서 할당 할 수 있는 최대 범위를 넘어가는 것!
언더플로 : 메모리 공간에서 할당 할 수 있는 최소 범위보다 작은 것!

### 스레드

스레드는 프로세스에서 실제로 실행되는 흐름의 단위이다.

스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역변수를 저장하는 스택 영역을 할당 받는다.
그리고 전역 변수를 저장하는 힙영역은 다른 스레드와 공유한다.

> 사용자 레벨 스레드와 커널 레벨 스레드
> 멀리스레드 환경에서 사용자 레벨 스레드와 커널 레벨 스레드는 3가지 관계가 있다.

> 1. 다대일 모델
>    사용자 레벨 스레드 n 개에 거널 레벨 스레드 1 개가 매핑된 형태
>    사용자 레벨에서 스레드를 관리한다.
>    하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨에 접근을 할수 없어 멀티 코어의 병렬성을 이용할 수 없다.

> 2. 일대일 모델
>    사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑된 형태
>    하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 다른 사용자 레벨 스레드가 모두 실행되지 않는 다대일 모델의 단점을 해결.
>    사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성되므로 성능 저하가 일어날수있다.

> 3. 다대다 모델
>    사용자 레벨 스레드 n 개에 커널 레벨 스레드 m 개가 매핑된 형태
>    커널 레벨 스레드 수는 사용자 레벨 스레드 수 이하이다.  
>    다대일 모델과 일대일 모델의 장점을 포함하였지만, 구현이 어렵다.

### PCB

OS 는 프로세스를 제어하기 위해 프로세스 정보를 저장하는데, Process Control Block(프로세스 제어 블록)이다.
프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID, 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어 주소 PC(프로그램 카운터), 프로세스 우선순위, 메모리 제한 등을 저장한다.

[그림 : PCB 저장 정보]

- 포인터
- 프로세스 상태
- PID
- PC
- 레지스터
- 메모리 제한
- 열린 파일 목록
- ...

### 프로세스의 생성

새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.  
fork() 함수는 함수를 호출한 프로세스를 복사하는 기능이 있다.  
이때 기존 프로세스를 부모 프로세스 라고 하고 , 복사된 프로세스를 자식 프로세스하고 한다.

> 부모 프로세스 에서 fork() 호출시, 부모 프로세스는 자식 프로세스의 PID 값을 반환, 자식 프로세스는 0을 반환

### 프로세스 상태도

모든 프로세스는 CPU에 의해 생성 ~ 소멸을 거친다.
5 가지 상태 (new, ready, waiting, running, terminated) 가 존재한다.

<!-- #  [그림 : 프로세스 상태도] -->

생성 : 프로세스가 PCB를 가지고 있지만 OS 로 부터 승인 받기전
준비 : OS 로 부터 승인 받은 후 준비 큐에서 CPU 할당을 기다림
실행 : 프로세스가 CPU를 할당받아 실행함
대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야해서 CPU 사용을 멈추고 기다림
종료 : 프로세스 실행을 종료함

프로세스 상태 변화
생성 -> 준비 : 생성 상태의 프로세스가 OS 로 부터 승인을 받아, 준비 상태의 프로세스가 모여 있는자료구조인 준비 큐에 추가됨
준비 -> 실행 : 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨
실행 -> 준비 : CPU 독점을 방지하기 위해 타임아웃되어 준비 상태로 변경됨
실행 -> 대기 : 입출력 또는 이벤트 때문에 대기 상태로 변경됨
대기 -> 준비 : 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
실행 -> 종료 : 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

---

승인 : CPU 를 제외한 다른 자원이 준비되어 해당 프로세스가 준비상태가 될수 있도록 OS가 허락하는것
디스패치 : 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것

---

### 멀티 프로세스와 멀티 스레드

멀티 프로세스와 멀티 스레드 개념에는 동시성과 병렬성이 개념을 알아야한다.

동시성 : 싱글 코어에서 여러 작업을 번갈아 가면서 처리하는 방식.

- CPU 는 한번에 하나의 작업만 처리가능하여 여러작업을 돌아가면서 조금씩 작업한다.

=> 이렇게 여러작업을 돌아가면서 조금씩 작업해 교체하는 것을 **콘텍스트 스위칭** 이라고 한다.

병렬성 : CPU 가 여러개 있어서 (=멀티코어) 각 CPU 에서 각 작업을 동시에 처리하는 방식.

#### 멀티 프로세스

- 응용프로그램 하나에 여러 프로세스를 구성하는 것
- 멀티 프로세스 환경에서는 하나의 프로세스가 죽어도 다른 프로세스에 영향이 가지 않는다.
  > 응용프로그램을 프로세스 하나로 구성하는 것보다 여러개로 구성하는것이 안정적

단점 : 시간과 메모리 공간을 많이 사용한다.
=> CPU 하나에 프로세스 하나만 처리 가능한데, 여러 (작업)프로세스를 처리하려면 처리 중인 프로세스를 교체하려는 작업(콘텍스트 스위칭)을 해야한다. 이때 CPU 에서 기존 처리하는 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용가능하게 교체하면서 **시간과 메모리가 필요하다(= 오버헤드)**
또한 프로세스는 독립적인 메모리를 할당받는다. 따라서 프로세스 간 공유자원이 있다면 IPC 를 통해 프로세스 간에 자원을 공유해야한다.

<!-- ---
IPC (Inner Process Communication) =>
--- -->

#### 멀티 스레드

스레드를 여러개 생성해 스레드들이 각자 다른 작업을 처리하도록 하는 것
멀티 스레드는 스레드 간에 힙, 데이터, 코드 영역을 공유하기 때문에 콘텍스트 스위칭 할때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 됨으로써 멀티 프로세스 단점을 보완하였다.  
따라서 독립적인 메모리 공간을 갖는 프로세스를 여러개 생성하는 것보다(멀티프로세스) 스레드를 여러개 생성하는 것이 자원을 효율적으로 사용할 수 있다.  
스레드 간의 자원 공유가 프로세스 간의 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간이 단축된다.
단점 :
스택 영역을 다른 스레드와 함께 사용하므로 공유 자원에 대한 동기화가 필수고, 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향이 미칠수 있다.

<!--

## 스케줄링

## 메모리 관리 전략

## 가상 메모리

## 캐시 메모리

-->
