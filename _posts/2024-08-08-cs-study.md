---
# 제목
title: "CS 관련 공부 (1) 운영체제란!"
# 부가 내용 미리보기
excerpt: "운영체제, 목적, CPU와 메모리 구조, 커널과 시스템 콜에 대해 작성을 한 내용입니다."

# 해당 카테고리
categories:
  - CS
# 태그
tags:
  - [cs, study, 기술 면접 대비]

#
permalink: /cs/study/

toc: true
toc_sticky: false

date: 2024-08-08

last_modified_at: 2024-12-08

# true 활성 (default), false 비활성
published: false
---

# 🦥 [운영체제]

> 책을 읽고 내가 이해하기 쉽게, 기억하기 쉽게 작성한 게시물입니다.

## 운영체제란?

> **O**perating **S**ystem 은 컴퓨터 시스템의 **자원 관리**,  
> 사용자에게 컴퓨터를 사용할 수 있는 **환경을 제공**해주는 역할을 한다.

---

## [운영체제의 목적]

> **한정된 컴퓨터의 자원을 관리** 하기 위함이다.

1. 처리 능력 향상 : OS 는 자원 관리를 통해 일정시간 안에 시스팀 처리량을 향상시킨다.
2. 반환 시간 단축 : OS 는 사용자가 요청한 작업의 완료 되어지는 시간을 단축시킨다.
3. 사용 가능도 향상 : OS 는 사용자가 컴퓨터 사용해야할때 자원을 즉시 제공해준다.
4. 신뢰도 향상 : OS 는 입력한 값에 대한 결과 값을 정확하게 줄수 있도록 신뢰도를 향상해야한다.

OS 는 하드웨어와 소프트웨어를 이어주는 계층이며, 한정된 자원에서 빠르게 문제를 해결하는 것이 목적이다.
그래서 OS 성능 평가 기준으로 사용된다.

---

## [CPU 와 메모리 구조]

> CPU 는 연산을 처리하고 수행하며, **프로세서** 라고 불린다.  
> 메모리는 데이터를 기억하기 위한 장치이다.

> 주 기억장치인 메인 메모리는 우리가 흔히 말하는 RAM 을 가르키는 말이다.

> 보조 기억장치는 **SSD**(Solid State Drive), **HDD**(Hard Disk Drive) 등을 가르킨다.

휘발성 메모리(전원 나가면 사라짐) => **주** 기억장치  
비휘발성 메모리(전원이 나가도 사라지지 않음) => **보조** 기억장치

메모리는 CPU 빠르게 접근 하도록 아래의 계층 구조로 나뉜다.

---

## [커널과 시스템 콜]

> 커널은 OS 의 핵심요소, 컴퓨터 하드웨어와 프로세스의 보안, 자원관리, 하드웨어 추상화 같은 중요한 역할을 수행한다. **특히**, 자원 관리를 위해 CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등을 담당한다.

OS 는 중요자원 보호를 위해 커널모드, 사용자모드 두가지가 있다.

커널 모드 : 하드웨어에 직접 접근해 메모리, cpu 같은 자원을 사용할 수 있다.

사용자 모드 : 커널모드의 자원에 접근할수 없게 제한을 두어 자원에 접근하려면 **_시스템 콜_**을 호출해야 자원 사용할 수 있다.

`시스템 콜 : 사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수이다. `

시스템 콜을 사용해 프로세스 제어, 파일 조작, 장치 관리, 데이터의 유지보수, 통신, 보호를 할 수 있다.

대표적 예 :

1. 프로세스 생성 => fork()
2. 부모 프로세스가 자식 프로세스의 수행을 기다리는 wait() 등이 있다.

시스템 콜에서 커널에 매개변수를 전달하는 방법은 3가지이다.

1. 매개변수를 CPU의 레지스터에 직접 전달하는 방식이다. 이 방식은 매개변수의 개수가 레스터의 개수보다 많은 경우에 문제가 될 수 있어서 권장하지 않는다.
2. 매개변수를 메모리에 저장한 후 메모리의 주소 값을 레지스터에 저장하는 방식이다.
3. 매개변수를 프로그램의 스택에 push 하고 OS 에서 pop해 매개변수를 전달하는 방식이다.

---

## [프로세스]

프로세스는 컴퓨터에서 실행중인 하나의 프로그램을 의미한다.

프로세스 = 하나의 프로그램 = 명령어의 집합

OS 는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다.

프로세스는 OS로 부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당 받고 다른 프로세스의 메모리 영역에 접근할 수 없다.

> ### 스택
>
> 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역이다.
> 높은 주소 값에서 낮은 주소값으로 메모리 할당되며, 영역 크기는 컴파일 때 결정된다.

> ### 힙
>
> 사용자에 의해 동적 메모리 할당이 일어나는 영역이다.  
> C 언어에서 malloc() 으로 할당되는 영역,
> 낮은 주소 값에서 높은 주소 값으로 메모리 할당되며, 영역 크기는 런타임 때 결정된다.

> ### 데이터
>
> 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다.  
> 데이터 영역은 세부적으로 BSS(Block Stated Symbol) 영역과 데이터 영역으로 나눌수 있다. BSS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장한다.

> ### 코드
>
> 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로, 텍스트 영역이라고도 한다.

스택 영역과 힙 영역은 동적으로 메모리 할당이 가능해서 두영역사이에 빈공간이 존재한다.
스택 영역은 `후입선출(LIFO)`, 높은 주소값 -> 낮은 주소값 순서로 사용!
힙 영역은 `선입선출(FIFO)`, 낮은 주소값 -> 높은 주소값 순서로 사용!

하지만 메모리 영역을 공유하기 떄문에 서로의 영역을 침범하는 문제가 생긴다.
스택 영역이 힙 영역을 침범하는 경우 => 스택 오버플로우(stack overflow)
힙 영역이 스택 영역을 침범하는 경우 => 힙 오버플로우(heap overflow)

오버플로 : 메모리 공간에서 할당 할 수 있는 최대 범위를 넘어가는 것!
언더플로 : 메모리 공간에서 할당 할 수 있는 최소 범위보다 작은 것!

### 스레드

스레드는 프로세스에서 실제로 실행되는 흐름의 단위이다.

스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역변수를 저장하는 스택 영역을 할당 받는다.
그리고 전역 변수를 저장하는 힙영역은 다른 스레드와 공유한다.

> 사용자 레벨 스레드와 커널 레벨 스레드
> 멀리스레드 환경에서 사용자 레벨 스레드와 커널 레벨 스레드는 3가지 관계가 있다.

> 1. 다대일 모델
>    사용자 레벨 스레드 n 개에 거널 레벨 스레드 1 개가 매핑된 형태
>    사용자 레벨에서 스레드를 관리한다.
>    하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨에 접근을 할수 없어 멀티 코어의 병렬성을 이용할 수 없다.

> 2. 일대일 모델
>    사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑된 형태
>    하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 다른 사용자 레벨 스레드가 모두 실행되지 않는 다대일 모델의 단점을 해결.
>    사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성되므로 성능 저하가 일어날수있다.

> 3. 다대다 모델
>    사용자 레벨 스레드 n 개에 커널 레벨 스레드 m 개가 매핑된 형태
>    커널 레벨 스레드 수는 사용자 레벨 스레드 수 이하이다.  
>    다대일 모델과 일대일 모델의 장점을 포함하였지만, 구현이 어렵다.

### PCB

OS 는 프로세스를 제어하기 위해 프로세스 정보를 저장하는데, Process Control Block(프로세스 제어 블록)이다.
프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID, 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어 주소 PC(프로그램 카운터), 프로세스 우선순위, 메모리 제한 등을 저장한다.

[그림 : PCB 저장 정보]

- 포인터
- 프로세스 상태
- PID
- PC
- 레지스터
- 메모리 제한
- 열린 파일 목록
- ...

### 프로세스의 생성

새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.  
fork() 함수는 함수를 호출한 프로세스를 복사하는 기능이 있다.  
이때 기존 프로세스를 부모 프로세스 라고 하고 , 복사된 프로세스를 자식 프로세스하고 한다.

> 부모 프로세스 에서 fork() 호출시, 부모 프로세스는 자식 프로세스의 PID 값을 반환, 자식 프로세스는 0을 반환

### 프로세스 상태도

모든 프로세스는 CPU에 의해 생성 ~ 소멸을 거친다.
5 가지 상태 (new, ready, waiting, running, terminated) 가 존재한다.

<!-- #  [그림 : 프로세스 상태도] -->

생성 : 프로세스가 PCB를 가지고 있지만 OS 로 부터 승인 받기전
준비 : OS 로 부터 승인 받은 후 준비 큐에서 CPU 할당을 기다림
실행 : 프로세스가 CPU를 할당받아 실행함
대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야해서 CPU 사용을 멈추고 기다림
종료 : 프로세스 실행을 종료함

프로세스 상태 변화
생성 -> 준비 : 생성 상태의 프로세스가 OS 로 부터 승인을 받아, 준비 상태의 프로세스가 모여 있는자료구조인 준비 큐에 추가됨
준비 -> 실행 : 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨
실행 -> 준비 : CPU 독점을 방지하기 위해 타임아웃되어 준비 상태로 변경됨
실행 -> 대기 : 입출력 또는 이벤트 때문에 대기 상태로 변경됨
대기 -> 준비 : 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
실행 -> 종료 : 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

---

승인 : CPU 를 제외한 다른 자원이 준비되어 해당 프로세스가 준비상태가 될수 있도록 OS가 허락하는것
디스패치 : 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것

---

### 멀티 프로세스와 멀티 스레드

멀티 프로세스와 멀티 스레드 개념에는 동시성과 병렬성이 개념을 알아야한다.

동시성 : 싱글 코어에서 여러 작업을 번갈아 가면서 처리하는 방식.

- CPU 는 한번에 하나의 작업만 처리가능하여 여러작업을 돌아가면서 조금씩 작업한다.

=> 이렇게 여러작업을 돌아가면서 조금씩 작업해 교체하는 것을 **콘텍스트 스위칭** 이라고 한다.

병렬성 : CPU 가 여러개 있어서 (=멀티코어) 각 CPU 에서 각 작업을 동시에 처리하는 방식.

#### 멀티 프로세스

- 응용프로그램 하나에 여러 프로세스를 구성하는 것
- 멀티 프로세스 환경에서는 하나의 프로세스가 죽어도 다른 프로세스에 영향이 가지 않는다.
  > 응용프로그램을 프로세스 하나로 구성하는 것보다 여러개로 구성하는것이 안정적

단점 : 시간과 메모리 공간을 많이 사용한다.
=> CPU 하나에 프로세스 하나만 처리 가능한데, 여러 (작업)프로세스를 처리하려면 처리 중인 프로세스를 교체하려는 작업(콘텍스트 스위칭)을 해야한다. 이때 CPU 에서 기존 처리하는 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용가능하게 교체하면서 **시간과 메모리가 필요하다(= 오버헤드)**
또한 프로세스는 독립적인 메모리를 할당받는다. 따라서 프로세스 간 공유자원이 있다면 IPC 를 통해 프로세스 간에 자원을 공유해야한다.

<!-- ---
IPC (Inner Process Communication) =>
--- -->

#### 멀티 스레드

스레드를 여러개 생성해 스레드들이 각자 다른 작업을 처리하도록 하는 것
멀티 스레드는 스레드 간에 힙, 데이터, 코드 영역을 공유하기 때문에 콘텍스트 스위칭 할때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 됨으로써 멀티 프로세스 단점을 보완하였다.  
따라서 독립적인 메모리 공간을 갖는 프로세스를 여러개 생성하는 것보다(멀티프로세스) 스레드를 여러개 생성하는 것이 자원을 효율적으로 사용할 수 있다.  
스레드 간의 자원 공유가 프로세스 간의 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간이 단축된다.
단점 :
스택 영역을 다른 스레드와 함께 사용하므로 공유 자원에 대한 동기화가 필수고, 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향이 미칠수 있다.

[그림 : 멀티 스레드 구조]

```
===========================
          *프로세스*
*코드*    *데이터*      *힙*

------------   -------------
| *스레드1*  |   *스레드2*   |
|  스택     |     스택      |
-----------  -----------
===========================
```

#### 콘텍스트 스위칭

콘텍스트 스위칭을 이해하기 전 인터럽트(interrupt)라는 개념도 알아야한다.
인터럽트(=방해하다) CPU 에서 프로세스를 처리하다 입출력 이벤트 발생하거나 예외 상황이 발생할때 이에 대응할 수 있게 CPU에 처리 요청 하는 것
인터럽트는 입출력 발생시, CPU 사용시간이 만료 되었을 시, 자식프로세스를 생성할시에 발생한다.

CPU는 하나의 작업(프로세스)만 처리할수 있다. 멀티 프로세스로 처리하려면 CPU 스케줄러를 통해 인터럽트가 발생하면서 콘텍스트 스위칭이 이뤄진다.

> 콘텍스트(context) == CPU 가 처리하는 하나의 프로세스 정보
> 즉, 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것!

> 여기서 CPU 에서 처리중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할수 있던 이유는 ?  
> PCB (= Program Counter Block)에 프로그램 카운터와 스택 포인터 값이 저장 되어있기 때문!
> 프로그램 카운터 => 프로세스가 이어서 처리해야하는 명령어의 주소값
> 스택 포인터 => 스택 영역에서 데이터가 채워진 가장 높은 주소값
> 그렇기 때문에, 다음 실행할 명령어의 주소값이 뭐고, 데이터가 스택 어디까지 채워져있는지 알아서 콘텍스트 스위칭이 원활히 가능하다

#### 프로세스 동기화

1.경쟁상태

- 공유 자원에 동시에 접근해 경쟁하는 상태이다.
- 여러 프로세스 또는 스레드가 하나의 공유자원에 접근하는 경우를 말한다.

> 예 : 엄마가 냉장고에 우유가 없는것을 확인하고 -> 우유를 사러 마트로 간다. -> 엄마가 우유를 사고 돌아오는길에 내가 냉장고에 우유가 없다는것을 확인하고 -> 내가 우유를 사러 마트에 간다 -> 내가 우유를 사서 집에온다.

우유를 중복으로 2개를 사러 갔다오는 경우가 발생한다.

냉장고 => 공유 자원

엄마, 나 => 각각의 프로세스

각각의 프로세스가 공유 자원에 동시에 접근해서 원치 않은 결과를 발생시킨다. 그렇기에 문제해결을 위해선 프로세스 동기화를 해야한다.

2.임계상태

- 공유 자원에 접근 가능하고 접근 순서에 따라 결과가 달라지는 코드 영역이다.
  임계영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유자원에 접근해도 데이터의 일관성이 유지되도록 프로세스 동기화를 해야한다.
  그렇기에 3가지 조건을 충족시켜야한다.
- 1. 상호배제기법(mutual exclusive) : 어떤 프로세스가 임계영역을 실행 중일때 다른 프로세스는 접근할 수 없다. 뮤텍스, 세마포어
- 2. 진행(progress) : 임계영역을 실행 중인 프로세스가 없을때 다른 프로세스가 임계영역을 실행한다.
- 3. 한정된 대기(bounded waiting) : 임계 영역에 접근을 요청했을때 무한한 시간을 기다리지 않는다.

##### 뮤텍스

락을 가진 프로세스만이 공유자원에 접근이 가능하게 하는 방법
예 : 식당에 열쇠 하나뿐인 하나의 화장실이 있다.  
내가 열쇠를 가지고 화장실에 간다.  
화장실 가려던 친구는 열쇠가 없어 기다린다.  
내가 열쇠를 반납하면, 친구는 열쇠를 가지고 화장실에 간다.

화장실 => 공유자원을 포함한 임계영역
열쇠 => 락
나, 친구 => 공유자원에 접근하려는 프로세스

임계 영역에 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기전까지 대기해야한다.
이러한 행동을 *락킹 매커니즘*이라고 한다.

임계영역에 접근 못한 프로세스는 락을 얻기위해 반복문으로 락이 풀렸는지 확인한다. 이 행동을 바쁜대기 종류 중 *스핀락*이라고 한다.

프로세스가 대기 상태가 되지 않고 스핀락을 하기때문에 빠르게 프로세스가 교체될 수 있다.

##### 세마포어

공유 자원에 접근 할 수 있는 프로세스 수를 정해 접근 제어하는 방법이다.

예 : 식당에 3칸의 화장실과 3 개의 열쇠가 있다.
나, 친구A, 친구B, 친구C가 있고, 친구A, 친구B, 친구C 가 각 열쇠를 가져서 화장실간다.
나는 남은 열쇠가 없어서 화장실에 못간다.
화장실에 간 셋중 하나가 열쇠를 돌려놓으면, 내가 화장실에 간다.

화장실 => 공유 자원을 포함한 임계영역  
나, 친구A, 친구B, 친구C => 공유 자원에 접근하는 프로세스  
임계영역에 접근 가능한 키 수 n개를 지정하고 키를 가진 프로세스만이 접근가능한다.  
공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고해서 *시그널링 매커니즘*이라고 한다.

#### 교착상태

상호배제 기법때문에 2 개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태이다.
4가지 충분 조건이다.

- 상호배제 : 하나의 공유 자원에 프로세스만 접근할 수 있다.
- 점유와 대기 : 프로세스 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용중인 자원을 점유하기 위해 대기한다.
- 비선점 : 다른 프로세스에 할당된 자원을 뺏을 수 없다.
- 환형대기 : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

교착상태를 방지하기 위한 4가지 필요 충분 조건 중 한가지를 제거하면 된다.

- 상호배제 부정 : 여러 프로세스가 동시에 하나의 공유자원을 사용할수 있게 한다.
- 점유와 대기부정 : 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 대기를 없앤다. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구한다.
- 비선점 부정 : 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납한다.
- 환형 대기 부정 : 자원을 선형 순서로 정렬해 고유 번호를 할당한다. 그릭 각 프로세스에서 요구할 수 있는 번호의 방향을 정해 한쪽 방향으로만 자원을 요구하게 한다.

#### 스레드 안전

멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스래드 여러개가 동시에 접근해도 문제가 없다는것을 의미한다.

스레드의 안전이 이뤄지지 않은 경우는 예상 밖의 결과가 나온다. 프로세스 동기화를 시켜야한다.

```
var++;
```

case 1

- _스레드1_
- 1. var 값을 메모리에서 CPU 레지스터로 로드 (var = 0)
- 4. 연산수행 (var = 1)
- 5. var 값을 메모리에 저장 (var = 1)
- _스레드2_
- 2. var 값을 메모리에서 CPU 레지스터로 로드 (var = 0)
- 3. 연산수행 (var = 1)
- 6. var 값을 메모리에 저장 (var = 1)

case 2

- _스레드1_
- 1. var값을 메모리에서 CPU 레지스터로 로드 (var = 0)
- 2. 연산 수행 (var = 1)
- 3. var 값을 메모리에 저장 (var = 1)
- _스레드2_
- 4. var값을 메모리에서 CPU 레지스터로 로드 (var = 1)
- 5. 연산 수행 (var = 2)
- 6. var 값을 메모리에 저장 (var = 2)

스레드 안전을 위한 조건
상호배제 : 공유 자원에 접근해야할 때 뮤텍스 또는 세마포어 같은 상호배제 기법을 사용해 접근을 통제한다.
원자 연산 : 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 한다.
원자 연산 => 연산했다 or 안했다 두가지만 존재하는 연산
재진입성 : 특정 함수를 하나의 스레드에서 실행중일때 다른 스레드가 해당함수를 실행해도 각 스레드에 올바른 결과가 나올수 있게 한다.
스레드 지역 저장소 : 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄인다.

#### IPC

프로세스는 고유한 메모리 영역을 가지고 있기때문에 프로세스간의 자원 공유를 위해서는 *IPC*를 해야한다.  
IPC (Inter Process Communication) 의 약자이며, 프로세스 간 자원 공유 방식을 나타낸다.
대표적 졸류

1. 공유 메모리 (shared memory) : 프로세스간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식이다. 여러 프로세스에서 접근할수 있어 동기화 문제가 발생할 수 있다.
2. 소켓 (socket) : 네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용가능하다. 클라이언트와 서버 구조로 자원을 주고받는다.
3. 세마포어 (semaphore) : 접근하는 프로세스를 제어해 공유 자원을 관리한다.
4. 파이프 (pipe) : FIFO 형태의 메모리인 파이플를 이용해 프로세스 간 자원을 공유하는 방식이다. 파이프는 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 잇다. 따라서 양방향 통신을 하려면 읽기 파이프, 쓰기 파이프를 각각 생성해야한다.
5. 메세지 큐 (message que) : FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메세지를 주고 받는 형식이다.

#### 좀비 프로세스와 고아 프로세스

좀피프로세스 :
부모프로세스가 자식프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식프로세스를 *좀비프로세스*라고한다.
자식 프로세스가 종료딜때 부모 프로세스에 SIGCHILD 라는 시그널을 보내면 부모프로세스에서 wait() 함수(시스템 콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.
이때, 자원 회수에 실패하면 좀비프로세스가 생긴다. 많이 쌓이게 되면 자원 낭비가 될수 있다.

고아프로세스 :  
부모프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 *고아프로세스*라고 한다.  
이럴때는 자식프로세스의 부모 PID 를 init 프로세스(부팅 시 가장 먼저 실행되는 프로세스) 의 PID 인 1로 바꿔준다.  
이렇게 하면 고아 프로세의 부모 프로세스는 init 프로세스가 된다. 이후에 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수해 좀비 프로세스가 되는것을 방지할 수 있다.

> 두 단어 모두 자식 프로세스를 가르키는 단어 이며, 부모가 자식 죽은 신호를 회수 못하면 좀비, 부모가 자식보다 먼저 죽으면 고아라고 칭함

## 스케줄링

멀티프로세스 환경에서는 여러 프로세스가 모두 실행되어야 하지만, CPU 자원은 한정적이기 때문에, 스케쥴링을 통해 효율적으로 모든 프로세스를 공평하게 실행시킨다.
그렇기에 OS 에서 스케쥴링은 매우 중요한 개념으로 목적, 단계, 용어를 알고 있어야한다.

### 스케줄링의 목적

주 목적은 멀티프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것을 5가지로 분류할 수 있다.

1. 공평성 : 모든 프로세스가 공평하게 실행되어야한다. 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링 해야한다.
2. 효율성 : 자원을 효율적으로 사용되도록 자원이 사용되지 않는 시간이 없도록 스케줄링 해야한다.
3. 안정성 : 우선 순위를 고려해 높은 우선 순위의 프로세스를 먼저 처리하도록 스케줄링 해야한다.
4. 반응 시간 보장 : 프로세스가 오랜시간 응답이 없으면 시스템이 멈춘것으로 생각하기에, 일정 시간내에 응답할 수 있도록 스케줄링 해야한다.
5. 무한 연기 방지 : 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링 해야한다.

### 스케줄링의 단계

장기, 중기, 단기 3가지로 나뉜다.

- 장기 스케줄링 : 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절한다. (잡 스케줄링 or 승인 스케줄링이라고 한다.)
  현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다.
- 중기 스케줄링 : 메모리에 로드된 프로세스 수를 동적으로 조절한다. 메모리에 프로세스가 많이 로드되면 스왑 아웃해서 일부 프로세스를 통째로 저장한다.  
  스왑아웃된 프로세스는 중단 상태가 된다. 중단 상태는 준비 상태에서 스왑 아웃된 중단된 준비 상태와 대기 상태에서 스왑아웃된 중단된 대기 상태로 구분된다.
- 단기 스케줄링 : 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정한다.  
  즉, 어떤 프로세스를 디스패치할지 결정하는데, 이를 CPU 스케줄링이라고 한다.

### 스케줄링 알고리즘

CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는데 사용한다.
스케줄링 목적을 달성하기 위해 평가하기 위한 기준이 있다.

- CPU 사용률 : CPU 를 놀라지 않고 사용하는지 판단
- 처리량 : 단위시간(time unit) 당 실행한 프로세스 수
- 응답 시간 : 프로세스에 요청이 발생했을 때 응답까지 발생했을때 응답까지 걸리는 시간
- 반환 시간 : 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- 대기 시간 : 프로세스가 대기 큐에서 대기하는 시간의 총합

스케줄링 알고리즘에는 비선점형과 선점형으로 나뉜다.

1. 비선점형 스케줄링
   실행중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미한다.
   해당 알고리즘으로는 FCFS (First Come First Served) 스케줄링, SJF(Shortest Job First) 스케줄링, HRRN(Highest Response Ratio Next) 스케줄링이 있다.

- FCFS 스케줄링 : 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘이다. 준비 큐에 먼저 들어온 프로세스를 먼저 실행한다.
- SJF 스케줄링 : 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘으로, SJN(Shortest Job Next) 스케줄링이라고도 한다. 준비 큐에 있는 프로세스중 CPU 를 점유하는 실행시간이 가장 짧은 프로세스(Shortest job)부터 실행한다. 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있다.

> 기아상태 => 프로세스마다 우선순위가 있는데, 우선순위가 높은 프로세스만 수행되어 우선 순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것을 의미한다.

2. 선점형 스케줄링
   스케줄러가 실행중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미한다.
   RR(Round Robin), SRTF(Shortest Remaining Time First), 멀티레벨(multi level) 3 가지 종류가 있다.

RR 스케줄링 : 비선점형 스케줄링과 달리 프로세스 간 우선순위가 없다. 모든 프로세스를 순서대로 일정 시간동안 실행하며, 일정 시간을 초과하면 다른 프로세스를 실행한다. 여기서 일정 시간은 '시간 단위'를 의미하며 타임 퀀텀(time quantum) 또는 타임슬라이스(time slice)라고도 한다. 일반적으로 시간 단위는 10 ~100 밀리초다. 콘텍스트 스위칭이 빈번하게 일어나서 오버헤드가 크다는 단점이 있지만, 모든 프로세스가 반복 수행되어 응답속도가 빠르다는 장점이 있다.

SRTF 스케줄링 : 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하느 알고리즘이다. 한 프로세스가 실행 중일때 실행 시간이 더 짧은 프로세스가 주비 큐에 들어오면 실행시간이 더짧은 프로세스가 CPU를 차지하게 된다. 평균 대기 시간이 짧다는 장점이 있지만, 수행 시간이 긴 프로세스는 기아 상태가 되기 쉽다.

멀티 레벨 스케줄링 : 준비 큐를 목적에 따라 여러개로 분리해 사용하는 알고리즘이다. 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용할 수 있다. 여러 개의 큐는 foreground 큐와 background 큐로 나뉜다. foreground 큐에는 응답 속도가 중요한 프로세스가 들어가고, background 큐에는 응답 속도보다 성능을 중요시하는 프로세스가 들어간다.

## 메모리 관리 전략

다수의 프로세스를 실행하려면 한정된 메모리 공간에 많은 프로세스를 로드 할 수 있어야한다. 그래서 메모리 공간을 더 효율적인 활용하기 위한 방법으로 연속 메모리 할당, 페이징, 세그먼테이션 등이 있다. 작동방식과 장단점을 이해해야 가상메모리를 좀더 쉽게 이해 가능하다.

### 논리 메모리와 물리 메모리

CPU 가 프로세스를 처리할 때 보는 주소 값과 실제 메모리의 주소값은 다르다.  
프로세스가 보는 메모리 영영을 논리 메모리 영역 또는 가상 메모리 영역이라고 하고, 실제로 사용되는 메모리 영역을 물리 메모리영역이라고 한다. 그리고 CPU 가 프로세스를 실행하며 보는 주소값을 논리 주소 또는 가상 주소라고 하며, 실제 메모리에서 사용되는주소는 물리 주소라고 한다.
위에 설명했듯이 주소가 다르므로 논리 주소를 물리 주소로 변환해줘야하는데, 이 동작을 하는 하드웨어 장치를 메모리 관리 장치(MMU, Memory Management Unit) 라고 한다.
MMU 는 CPU 에 위치하며, CPU에서 메모리에 접근하기 전에 MMY를 거쳐 논리 주소에 해당하는 물리 주소를 얻는다.
MMU는 보호해야하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할을 한다.

### 연속 메모리 할당

연속 메모리 할당은 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로듣하느 방법이다.
고정 분할 방식, 가변 분할 방식 2가지 연속 메모리 할당 방법이 있다.

### 고정 분할 방식

고정 분할은 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당 하는 방식이다.
이때, 분할된 영역의 크기는 서로 다를 수 있으며, 분할된 크기는 고정된다. 하지만, 이방식은 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점이 있고, 단편화 문제가 발생할 수 있다.

### 가변분할 방식

가변 분할은 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식이다.
이 방식은 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드 될 수 있는 메모리 공간을 갖는다. 메모리 할당 알고리즘으로는 최초 적합, 최적 적합, 최악 적합 등이 있다.

1. 최초 적합
   가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식이다.
2. 최적 적합
   할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식이다. 이 방식은 가용 메모리 공간을 모두 탐색해야한다.
3. 최악 적합
   할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식이다.  
   최적 적합 방식과 마찬가지로 가용메모리 공간을 모두 탐색해야한다.

### 비연속 메모리 할당

프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법을 비연속 메모리 할당이라고 한다.
페이징과 세그먼테이션 2가지 방식이 있다.

1. 페이징
   페이징 기법은 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지(page)와 프레임(frame)으로 나누는 것이다.(이때 페이지와 프레임의 크기는 같다.)  
   페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑한다.

페이지와 프레임을 매핑할때는 페이지 테이블(page table) 을 사용한다. 페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임 주소값을 저장한다. 페이지 테이블은 각 프로세스의 PCB에 저장된다.

페이징 기법을 사용하면 페이지를 물리메모리에 연속할당할 필요가 없어서 외부 단편화 문제 해결이 가능하다. 하지만, 프로세스 크기가 페이지 수로 나누어 떨어지는 보장하지 않기 때문에 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제가 또 발생할 수 있고 페이지 테이블 저장하기 위한 메모리 공간이 추가적으로 필요하다.

> 페이지 기법 추가적인 3가지
>
> 1. 계층적 페이징 : 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식으로 멀티 레벨 페이징이라고도 한다.
> 2. 해시 페이지 테이블 : 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱한 뒤 첫번째 요소와 가상 페이지 번호를 비교하는 방식.
> 3. 역 페이지 테이블 : 프레임을 이용해 페이지를 찾는 방식.

2. 세그먼테이션
   세그먼테이션 기법은 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당한다.
   논리적 단위 => 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미

이 기법은 세그먼테이션 테이블을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑한다. 세그먼트 테이블은 세그먼트 번호를 인덱스로 사용해, 세그먼트별 시작 주소인 base 와 세그먼트 길이인 limit을 저장한다.

프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉽다는 장점이 있다는 장점이 있지만, 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제가 발생할 수 있다. 또 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다. 이렇게 되면 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃 해야하는 단점이 있다.

## 가상 메모리

> 사용자가 프로그램을 실행하면 OS는 디스크에 저장된 데이터를 메모리로 로드한다. 하지만 메모리는 한정적이고, 사용자는 동시에 많은 프로그램을 실행하고 싶어한다. 그렇기에 메모리 공간의 한계 극복을 위해 가상 메모리라는 개념이 등장한다.

### 가상 메모리란

가상 메모리는 프로세스의 일부만 메모리에 로드하고, 나머지는 디스크에 둔 상태로 프로세스를 실행하는 방식이다.  
이 방식은 프로세스 전체가 메모리에 올라오지 않아도 프로세스 실행에 문제 없다는점을 착안했다. 사용자는 메모리에 전체 프로세스가 올라간것처럼 보이지만 사실은 가상 메모리인것이다.
그렇기에 더많은 프로세스를 메모리에 로드할 수 있다.

<!-- 가상 메모리 예 -->

가상 메모리의 장점 :

- 프로그램이 메모리 크기에 대한 제약을 덜 받을 수 있다.
- 동시에 많은 프로그램을 실행하므로 CPU 이용률과 처리율을 높일 수 있다.
- 필요한 영역만 메모리에 로드해 스와핑 횟수를 줄여서 프로그램 실행 속도를 높일 수 있다.

### 요구 페이징

요구페이징은 프로세스에서 필요한 페이지만 메모리에 로드하는 방식이다.  
페이지를 모두 메모리에 로드하지 않고 초기에 필요한 영역만 로드한 후 요청이 올때 다른 영역을 메모리에 로드한다.  
필요한 페이지를 물리 메모리에 로드하고, 필요하지 않은 페이지는 디스크에 저장한다.

<!-- 요구 페이징 예 -->

물리 메모리에 필요한 페이지가 없을때 (페이지 폴트라 칭함), 디스크에서 필요한 페이지를 스왑 인한다.

스왑인 할때 페이지에 해당하는 메모리 영역이 물리 메모리에 있는지는 페이지 테이블로 파악할 수 있다.

페이지 테이블은 페이지에 해당하는 프레임이 존재하면 v(valid) 값을, 존재하지 않거나 유효하지 않은 값은 i(invalid) 값을 반환한다.

<!-- 페이지 폴트가 발생할 때 상황  -->

### 스레싱

스레싱은 동시에 일정 수 이상의 프로그램을 실행했을때 오히려 CPU 이용률이 떨어지는 상황을 말한다.

가상메모리를 구현해 다중 프로그래밍을 하면 CPU 이용률이 높아지지만, 일정 수 이상으로 다중 프로그램을 하면 페이지 폴트가 자주 일어나서 디스크 영역에서 필요한 페이지 스왑인, 불필요한 페이지 스왑 아웃 하는 작업을 자주하게 된다.
위의 상황처럼 다중 프로그래밍 정도가 일정 수준 높아지면 페이징이 빈번하게 일어나 CPU 이용율이 떨어지는 스레싱이 발생한다.

<!-- 스레싱 발생 시점  -->

스레싱을 예방하려면 워킹 세트를 설정하는 방법이 있다.
지역성을 기반으로 자주 사용하는 페이지를 저장해두는 것을 의미한다.
워킹 세트를 바탕으로 자주사용하는 페이지를 물리 메모리의 프레임에 고정하면 페이지 폴트가 빈번하게 발생하는 현상을 방지 할 수 있다.

## 캐시 메모리

CPU 는 메모리에 접근해 많은 데이터를 처리한다. 이 시간을 줄이기 위해 자주 사용하는 데이터를 임시로 캐시 메모리에 저장한다.

### 캐시메모리와 지역성

캐시 메모리는 CPU와 메인 메모리 간에 데이터 접근시 속도 차이를 줄이기 위해 사용한다.

CPU 에서 메인 메모리에 있는 데이터를 가져올때 자주 사용하는 데이터는 캐시메모리에 저장한다. 이후에 해당 데이터가 필요하면 캐시 메모리에 접근해 메인 메모리에 접근하는 것 보단 속도를 향상시킬 수 있다.
캐시메모리에 어떤 데이터를 저장할지는 지역성을 바탕으로 결정한다. 지역성은 CPU가 자주 참조하는 데이터가 고르게 분포되지 않고 특정 부분에 몰려 있는 것을 나타낸다.
캐시 적중률을 높이려면 지역성을 바탕으로 데이터를 저장해야한다.

1. 시간 지역성 : 최근 참조한 내용을 다시 참조할 가능성이 높다.
2. 공간 지역성 : 실제 참조한 주소 근처의 내용을 참조할 가능성이 높다.

### 캐시메모리의 매핑 방식

캐시 메모리와 메인메모리를 매핑하는 3가지 방식이 있다.

- 직접 매핑 : 메인 메모리를 일정한 크기로 나누고 각 영역을 캐시 메모리에 매핑하는 방식이다. 메인 메모리는 캐시메모리보다 크므로 나눠진 n 개의 메모리 영역이 1개의 캐시 메모리에 매핑된다.
- 연관 매핑 : 메모리 영역을 캐시 메모리에 규칙 없이 매핑하는 방식이다. 메모리 영역을 캐시 메모리에 적재할 때는 간단하지만, 캐시 메모리에서 필요한 메모리 영역에서을 찾을때는 비효율적이다.
- 집합 연관 매핑 : 직접 매핑과 연관매핑을 결합해 단점을 보완한 방식으로 범용적으로 사용된다.

## 요약 정리

1 메모리 계층 구조

1. 사용 목적에 따라 메모리를 여러 계층으로 둠
2. 레지스터, 캐시메모리, RAM, 하드 디스크로 구성
3. CPU 접근속도 : 레지스터 > 캐시메모리 > RAM > 하드디스크

2 시스템 콜

1. 운영체제의 커널 모드에 접근해 필요한 기능을 수행하기 위해 프로세스에서 호출하는 함수
2. 프로세스 제어, 파일 조작, 장치 조작 등을 수행함

3 프로세스

1. 실행 중인 하나의 프로그램으로, 하나 이상의 스레드 가짐
2. PCB 에 프로세스의 현재 상태, PID, 부모 PID 등을 저장함
3. 프로세스마다 독립된 메모리 공간을 가짐

   - 스택 : 지역함수, 함수의 매개변수, 반환 주소 값 저장
   - 힙 : 동적 메모리 할당
   - 데이터 : 전역 변수, 정적 변수, 배열, 구조체 저장, 세부적으로 초기화된 데이터는 데이터 영역에, 초기화되지 않은 데이터는 BSS 영역에 저장됨
   - 코드 : 기계어

4. 프로세스의 상태

   - 생성 : 프로세스가 PCB를 가지고 있지만 OS 로부터 승인 받기전
   - 준비 : OS 로부터 승인 받은 후 준비 큐에서 CPU 할당을 기다림
   - 실행 : 프로세스가 CPU 를 할당받아 명령어를 실행함
   - 대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
   - 종료 : 프로세스 실행종료

5. 프로세스의 생성
   - fork() 함수 호출
   - 부모 프로세스는 자식 프로세스의 PID 를 , 자식 프로세스는 0을 반환함

4 스레드

- 프로세스에서 실제 실행되는 흐름의 단위
- 각 스레드는 스택 영역을 할당 받음
- 스택을 제외한 영역은 다른 스레드와 공유

5 멀티 프로세스와 멀티 스레드

1. 멀티 프로세스

   - 응용 프로그램을 여러 개의 프로세스로 구성하는 것
   - 프로그램을 하나의 프로세스로 구성하는 것보다 안정적임
   - 콘텍스트 스위칭으로 오버헤드가 발생함
   - 독립된 메모리 공간을 갖기 때문에 IPC 를 사용함

6 콘텍스트 스위칭

1. 멀티 프로세스 환경에서 CPU가 다른 프로세스를 처리하기 위해 처리 중인 프로세스를 변경하는 것
2. 처리하던 프로세스 정보를 저장하고, 다음으로 처리할 프로세스 정보를 레지스터에 로드하면서 오버헤드 발생

7 프로세스 동기화

1. 멀티 프로세스 환경에서 공유 자원의 일관성을 보장하기 위한 방법
2. 상호배제 기법 이용

- 뮤텍스 : 락을 가진 한 프로세스만 임계 영역에 접근 가능
- 세마포어 : 정해진 개수의 프로세스만 임계 영역에 접근 가능

8 교착 상태

1. 상호배제 : 하나의 공유 자원을 한개의 프로세스만 사용할 수 있음
2. 점유와 대기 : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스가 사용중인 자원을 점유하기 위해 대기함
3. 비선점 : 다른 프로세스에 할당된 자원을 뺏을 수 없음
4. 환형 대기 : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원 요구

9 CPU 스케줄링

1. 목적 : 모든 프로세스를 공평하게 실행하기 위함
2. 스케줄링 알고리즘의 종류

- FCFS : 비선점형, 선입 선출
- SJF : 비선점형, 실행 시간이 짧은 것부터 실행
- RR : 선점형, 타임 슬라이스(또는 타임 퀀텀) 동안만 프로세스 실행 후 교체
- SRTF : 선점형, 남은 프로세스 중 실행 시간이 가장 짧은 프로세스 실행

3. 스케줄러의 종류

- 장기 스케줄러 : 어떤 프로세스를 준비 큐에 넣을지 결정함
- 단기 스케줄러 : 준비 큐에 있는 프로세스 중 어떤 프로세스를 CPU 에 할당하지 결정함
- 중기 스케줄러 : 메모리에 로드된 프로세스 수 관리

10 비연속적 메모리 할당

1. 페이징

- 프로세스의 메모리 영역과 물리 메모리 영역을 일정 크기로 분할하는 방식
- 프로세스의 메모리 영역을 페이지로, 물리 메모리 영역을 프레임으로 나눔
- 내부 단편화 문제 방생 가능

2. 세그먼테이션

- 프로세스를 논리적 단위로 분할하는 방식
- 데이터를 보호하기 쉬움
- 스택 세그먼트 영여겡서 스택 오버플로 발생가능

11. 가상 메모리

- 메모리 공간의 한계를 극복 하기 휘애 고안한 방식으로, 프로세스 일부만 메모리에 올림
- 많은 프로세스를 메모리에 로드 할 수 있음
- 요구 페이징 : 필요한 페이지만 메모리에 로드, 페이지 폴트 발생 가능
- 스레싱 : 가상 메모리 환경에서 다중 프로그래밍 정도가 높아지면서 페이지 폴트가 빈번히 발생해 CPU이용률이 오히려 낮아지는 현상
